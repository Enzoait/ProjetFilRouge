name: Deploy with terraform

on: push

permissions:
  id-token: write
  contents: read

jobs:
  terraform_deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./infra
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          audience: sts.amazonaws.com
          role-to-assume: ${{ secrets.AWS_IAM_ROLE }}
          aws-region: eu-west-1

      - name: Build Frontend Docker image
        run: docker build -t enzoait/projetfilrouge-frontend:${{ github.sha }} ../frontend

      - name: Build Backend Docker image
        run: docker build -t enzoait/projetfilrouge-backend:${{ github.sha }} ../backend

      - name: Build Backend Lambda function
        run: |
          zip -r lambda_function_payload.zip infra/lambda/*

      - name: Login to ECR
        run: aws ecr get-login-password --region eu-west-1 | docker login --username AWS --password-stdin 304230205768.dkr.ecr.eu-west-1.amazonaws.com

      - name: Tag & Push Frontend
        run: |
          docker tag enzoait/projetfilrouge-frontend:${{ github.sha }} 304230205768.dkr.ecr.eu-west-1.amazonaws.com/projetfilrouge-frontend:${{ github.sha }}
          docker push 304230205768.dkr.ecr.eu-west-1.amazonaws.com/projetfilrouge-frontend:${{ github.sha }}

      - name: Tag & Push Backend
        run: |
          docker tag enzoait/projetfilrouge-backend:${{ github.sha }} 304230205768.dkr.ecr.eu-west-1.amazonaws.com/projetfilrouge-backend:${{ github.sha }}
          docker push 304230205768.dkr.ecr.eu-west-1.amazonaws.com/projetfilrouge-backend:${{ github.sha }}

      - name: Tag & Push Backend Lambda function
        run: |
          aws lambda update-function-code --function-name LambdaFunctionOverHttps --zip-file fileb://lambda_function_payload.zip

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init

      - name: Import existing resources
        run: |
          API_ID="${{ secrets.API_GATEWAY_ID }}"
          RESOURCE_ID="${{ secrets.RESOURCE_ID }}"
          STAGE_NAME="dev"

          # --- ECR FRONTEND ---
          if aws ecr describe-repositories --repository-names projetfilrouge-frontend > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_ecr_repository.frontend$'; then
              terraform import aws_ecr_repository.frontend projetfilrouge-frontend
            fi
          fi

          # --- ECR BACKEND ---
          if aws ecr describe-repositories --repository-names projetfilrouge-backend > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_ecr_repository.backend$'; then
              terraform import aws_ecr_repository.backend projetfilrouge-backend
            fi
          fi

          # --- S3 BUCKET ---
          if aws s3api head-bucket --bucket iimtib62673 2>/dev/null; then
            if ! terraform state list | grep -q '^aws_s3_bucket.main$'; then
              terraform import aws_s3_bucket.main iimtib62673
            fi
          fi

          # --- LAMBDA FUNCTION ---
          if aws lambda get-function --function-name LambdaFunctionOverHttps > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_lambda_function.lambda_function_over_https$'; then
              terraform import aws_lambda_function.lambda_function_over_https LambdaFunctionOverHttps
            fi
          fi

          # --- LAMBDA PERMISSION ---
          # On suppose que la Lambda existe déjà (vérifiée juste au-dessus)
          if ! terraform state list | grep -q '^aws_lambda_permission.apigw_lambda$'; then
            terraform import aws_lambda_permission.apigw_lambda LambdaFunctionOverHttps/AllowExecutionFromAPIGateway
          fi

          # --- API GATEWAY REST API ---
          if aws apigateway get-rest-api --rest-api-id $API_ID > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_api_gateway_rest_api.dynamo_db_operations$'; then
              terraform import aws_api_gateway_rest_api.dynamo_db_operations $API_ID
            fi
          fi

          # --- API GATEWAY STAGE ---
          if aws apigateway get-stage --rest-api-id $API_ID --stage-name $STAGE_NAME > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_api_gateway_stage.dynamodb_manager$'; then
              terraform import aws_api_gateway_stage.dynamodb_manager $API_ID/$STAGE_NAME
            fi
          else
            echo "Stage API Gateway $STAGE_NAME does not exist, skipping import."
          fi

          # --- API GATEWAY RESOURCE ---
          if aws apigateway get-resource --rest-api-id $API_ID --resource-id $RESOURCE_ID > /dev/null 2>&1; then
            if ! terraform state list | grep -q '^aws_api_gateway_resource.dynamodb_manager$'; then
              terraform import aws_api_gateway_resource.dynamodb_manager ${API_ID}/${RESOURCE_ID}
            fi
          fi

          # --- METHODS + RESPONSES ---
          methods=("POST" "GET" "PUT" "DELETE" "OPTIONS")

          for method in "${methods[@]}"; do
            lname="${method,,}_method"  # Ex: post_method
            method_exists=false

            # Vérifie que la méthode existe dans API Gateway (sinon on skippe tout le reste)
            if aws apigateway get-method \
              --rest-api-id "$API_ID" \
              --resource-id "$RESOURCE_ID" \
              --http-method "$method" > /dev/null 2>&1; then
              method_exists=true
            fi

            if [ "$method_exists" = true ]; then

              # API Gateway Method
              if ! terraform state list | grep -q "^aws_api_gateway_method.${lname}$"; then
                terraform import aws_api_gateway_method.${lname} ${API_ID}/${RESOURCE_ID}/${method}
              fi

              # API Gateway Integration
              if aws apigateway get-integration \
                --rest-api-id "$API_ID" \
                --resource-id "$RESOURCE_ID" \
                --http-method "$method" > /dev/null 2>&1; then

                if ! terraform state list | grep -q "^aws_api_gateway_integration.${lname}$"; then
                  terraform import aws_api_gateway_integration.${lname} ${API_ID}/${RESOURCE_ID}/${method}
                fi
              else
                echo "No integration found for $method — skipping import aws_api_gateway_integration.${lname}"
              fi

              # Method response name (ex: post_method_response_200)
              method_response_name="${lname}_response_200"

              if [ "$method" = "OPTIONS" ]; then
                # OPTIONS - method response
                if aws apigateway get-method-response \
                  --rest-api-id "$API_ID" \
                  --resource-id "$RESOURCE_ID" \
                  --http-method OPTIONS \
                  --status-code 200 > /dev/null 2>&1; then

                  if ! terraform state list | grep -q "^aws_api_gateway_method_response.options$"; then
                    terraform import aws_api_gateway_method_response.options ${API_ID}/${RESOURCE_ID}/OPTIONS/200
                  fi
                fi

                # OPTIONS - integration response
                if aws apigateway get-integration-response \
                  --rest-api-id "$API_ID" \
                  --resource-id "$RESOURCE_ID" \
                  --http-method OPTIONS \
                  --status-code 200 > /dev/null 2>&1; then

                  if ! terraform state list | grep -q "^aws_api_gateway_integration_response.options$"; then
                    terraform import aws_api_gateway_integration_response.options ${API_ID}/${RESOURCE_ID}/OPTIONS/200
                  fi
                fi

              else
                # Other methods - method response
                if aws apigateway get-method-response \
                  --rest-api-id "$API_ID" \
                  --resource-id "$RESOURCE_ID" \
                  --http-method "$method" \
                  --status-code 200 > /dev/null 2>&1; then

                  if ! terraform state list | grep -q "^aws_api_gateway_method_response.${method_response_name}$"; then
                    terraform import aws_api_gateway_method_response.${method_response_name} ${API_ID}/${RESOURCE_ID}/${method}/200
                  fi
                fi

                # Other methods - integration response
                if aws apigateway get-integration-response \
                  --rest-api-id "$API_ID" \
                  --resource-id "$RESOURCE_ID" \
                  --http-method "$method" \
                  --status-code 200 > /dev/null 2>&1; then

                  if ! terraform state list | grep -q "^aws_api_gateway_integration_response.${lname}$"; then
                    terraform import aws_api_gateway_integration_response.${lname} ${API_ID}/${RESOURCE_ID}/${method}/200
                  fi
                fi
              fi
            else
              echo "Méthode $method non trouvée dans l'API Gateway, skipping imports."
            fi
          done


      - name: Import existing OAC
        run: |
          terraform import aws_cloudfront_origin_access_control.s3_oac ${{ secrets.AWS_OAC_ID }}

      - name: Terraform Apply
        run: |
          terraform fmt
          terraform apply --auto-approve

      # - name: Terraform Destroy
      #   run: terraform destroy --auto-approve
